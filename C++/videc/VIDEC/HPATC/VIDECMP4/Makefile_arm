
#
# c.cpp混合编译的makefile模板
#
#

BIN = ../lib/libvidecmp4_arm.a
CPP = arm-linux-g++
#这里只加入库头文件路径及库路径
INCS = 
LIBS = 
SUBDIRS =
#生成依赖信息时的搜索目录，比如到下列目录中搜索一个依赖文件(比如.h文件)
DEFINC = -I. -I./include -I../include -I../
#
#
#maintest.c tree/rbtree.c  多了子目录，那就直接添加 目录/*.c即可   所有的源文件--  .c文件列表
CPPSRCS = $(wildcard \
			./libplatform/io/File.cpp \
			./libplatform/io/File_posix.cpp \
			./libplatform/io/FileSystem.cpp \
			./libplatform/io/FileSystem_posix.cpp \
			./libplatform/number/random_posix.cpp \
			./libplatform/process/process_posix.cpp \
			./libplatform/prog/option.cpp \
			./libplatform/sys/error.cpp \
			./libplatform/time/time.cpp \
			./libplatform/time/time.cpp \
			./libplatform/time/time_posix.cpp \
			./libplatform/time/MP4V2_time.cpp \
			./libutil/*.cpp \
			./src/bmff/*.cpp \
			./src/itmf/*.cpp \
			./src/qtff/*.cpp \
			./src/*.cpp \
			./VIDECMP4/VIDEC_MP4.cpp )

#
#
#所有的.o文件列表
CPPOBJS := $(CPPSRCS:.cpp=.o)
#
#生成依赖信息 -MM是只生成自己的头文件信息，-M 包含了标准库头文件信息。
#-MT 或 -MQ都可以改变生成的依赖  xxx.o:src/xxx.h 为 src/xxx.o:src/xxx.h 当然。前面的 src/xxx.o需自己指定
#格式为 -MM 输入.c或.cpp  查找依赖路径  -MT或-MQ  生成规则，比如src/xxx.o 
MAKEDEPEND = gcc -MM -MT
CXXFLAGS :=-march=i686
CPPFLAGS =

#-g 生成调试信息
#-pedantic参数与-ansi一起使用 会自动拒绝编译非ANSI程序
#-fomit-frame-pointer 去除函数框架
#-Wmissing-prototypes -Wstrict-prototypes 检查函数原型
#针对每个.c文件的.d依赖文件列表
CPPDEF = $(CPPSRCS:.cpp=.d)

$(MAKE) all CPPFLAGS="-w -Wall -DNDEBUG -DARM_LINUX_THREAD -O3"

all:$(BIN)

#生成.o的对自己目录中.h .c的依赖信息.d文件到.c所在的路径中
#$(DEF)文件是.d文件名列表(含目录)，比如tree.d 匹配成功那么%就是tree，然后在尝试%.c，如果成功。则执行规则
# $(<:.c=.o)是获取此.c文件的名字(含路径)，然后变为.o比如 src/xxx.o。 以形成如下
# src/xxx.o : src/xxx.c ***.h  ***.h  最前面！！注意。  
# 此做法是每个.d都和生成他的.c在一个目录里，所以需要这样做。
# $(<:.c=.o)之类的 。此时的<相当于变量$< 。切记
# : : :  含义同下
$(CPPDEF) : %.d : %.cpp
	$(MAKEDEPEND) $(<:.cpp=.o) $< $(DEFINC) > $@

#先删除依赖信息
#重新生成依赖信息
#这里出现了一个 $(MAKE) 没有定义的变量。这个变量是由 Make 自己定义的，它的值即为自己的位置，方便 Make 递归调用自己。
depend:
	-rm $(CPPDEF)
	$(MAKE) $(CPPDEF)

#$(OBJS):%.o :%.c  先用$(OBJS)中的一项，比如foo.o: %.o : %.c  含义为:试着用%.o匹配foo.o。如果成功%就等于foo。如果不成功，
# Make就会警告，然后。给foo.o添加依赖文件foo.c(用foo替换了%.c里的%)
# 也可以不要下面的这个生成规则，因为下面的 include $(DEF)  就隐含了。此处为了明了，易懂。故留着
$(CPPOBJS) : %.o: %.cpp
	$(CPP) -c $< -o $@ $(INCS) $(DEFINC) $(CPPFLAGS)

# $@--目标文件，$^--所有的依赖文件，$<--第一个依赖文件。每次$< $@ 代表的值就是列表中的
#
$(BIN) : $(CPPOBJS)
	arm-linux-ar r $(BIN) $(CPPOBJS)
	arm-linux-ranlib $(BIN)
#	$(CPP) $(LFLAGS) $(CPPOBJS)	-o $(BIN) $(LIBPATH)
#	-rm $(CPPOBJS)
# 链接为最终目标


#引入了.o文件对.c和.h的依赖情况。以后.h被修改也会重新生成，可看看.d文件内容即知道为何
#引入了依赖就相当于引入了一系列的规则，因为依赖内容例如： 目录/xxx.o:目录/xxx.c 目录/xxx.h 也相当于隐含的引入了生成规则
#故上面不能在出现如： $(OBJS) : $(DEF)之类。切记
#include $(CDEF) $(CPPDEF)
.PHONY:clean cleanall

#清除所有目标文件以及生成的最终目标文件
clean:			
	-rm $(BIN) $(CPPOBJS)
#rm *.d
cleanall:
	-rm $(BIN) $(CPPOBJS)

