// DM64Driver.cpp
//
// Generated by DriverWizard 3.2.0 (Build 2485)
// Requires DDK and DriverWorks
// File created on 9/29/2007
//
// This source file contains the implementation of a subclass of KDriver.
// WDM drivers implement a subclass of KDriver and override member
// function DriverEntry and AddDevice.
//

#define VDW_MAIN
#include <vdw.h>
#include "function.h"
#include "DM64Driver.h"
#include "DM64Queue.h"
#include "DM64Device.h"

#pragma hdrstop("DM64.pch")

// Memory allocation pool tag
// Override this value using the global function SetPoolTag().
POOLTAG DefaultPoolTag('46MD');

// Global driver trace object
// TODO:	Use KDebugOnlyTrace if you want trace messages
//			to appear only in checked builds.  Use KTrace if
//			you want trace messages to always appear.  Call
//			method SetOutputLevel to set the output threshold.
KDebugOnlyTrace T("DM64");

///////////////////////////////////////////////////////////////////////////////////////////////////
// Begin INIT section
#pragma code_seg("INIT")

DECLARE_DRIVER_CLASS(DM64Driver, NULL)

///////////////////////////////////////////////////////////////////////////////////////////////////
//  DM64Driver::DriverEntry
//		This routine is called when the driver is loaded.  Drivers often 
//		read the registry for configurable parameters.
//
//	Arguments:
//		IN	RegistryPath
//				pointer to a unicode string representing the path to
//				driver-specific key in the registry.  Look for:
//				HKLM\SYSTEM\CurrentControlSet\Services\DM64
//
//	Return Value:
//		NTSTATUS code
//
NTSTATUS DM64Driver::DriverEntry(PUNICODE_STRING RegistryPath)
{
	T.Trace(TraceInfo, __FUNCTION__"++. Compiled at " __TIME__ " on " __DATE__ "\n");

	NTSTATUS status = STATUS_SUCCESS;

	m_Unit = 0;

	// This macro suppresses compiler warning for unreferenced variable.
	// If you reference this parameter, simply remove the macro.
	UNREFERENCED_PARAMETER(RegistryPath);

	T.Trace(TraceInfo, __FUNCTION__"--. STATUS %x\n", status);

	return status;
}

///////////////////////////////////////////////////////////////////////////////////////////////////
#pragma code_seg()	// end INIT code
///////////////////////////////////////////////////////////////////////////////////////////////////

///////////////////////////////////////////////////////////////////////////////////////////////////
//  DM64Driver::AddDevice
//		This routine is called when the system detects a device for which this
//		driver is responsible.  This function creates the Functional Device 
//		Object, or FDO. The FDO enables this driver to handle requests for  
//		the physical device.
//
//	Arguments:
//		IN Pdo
//				Physical Device Object.  This is a pointer to a system device
//				object that represents the physical device.
//
//	Return Value:
//		NTSTATUS
//
NTSTATUS DM64Driver::AddDevice(PDEVICE_OBJECT Pdo)
{
	T.Trace(TraceInfo, __FUNCTION__"++.\n");

	NTSTATUS status = STATUS_SUCCESS;

	// Create DM64Device using a form of "placement" new
	// that is a member operator of KDevice.  This will use storage
	// in the system device object extension to store the class instance.
	DM64Device* pDevice = new (
            NULL,                    // no name
			FILE_DEVICE_UNKNOWN,
            NULL,                    // no name
			0,
			DO_DIRECT_IO | DO_POWER_PAGABLE
			)
		DM64Device(Pdo, m_Unit);

	if (pDevice == NULL)
	{
		status = STATUS_INSUFFICIENT_RESOURCES;
	}
	else
	{
		status = pDevice->ConstructorStatus();
		if (!NT_SUCCESS(status))
		{
			delete pDevice;
		}
		else
		{
			m_Unit++;
			pDevice->ReportNewDevicePowerState(PowerDeviceD0);
		}
	}

	T.Trace(TraceInfo, __FUNCTION__"--. STATUS %x\n", status);

	return status;
}

///////////////////////////////////////////////////////////////////////////////////////////////////
//  DM64Driver::Unload
//		This routine is called when the driver is unloaded.  Delete any
//		device objects created in DriverEntry by calling base class method
//		Unload().  Cleanup any allocations made for registry values in
//		DriverEntry.  
//
//	Arguments:
//		none
//
//	Return Value:
//		none
//
VOID DM64Driver::Unload(VOID)
{
	T.Trace(TraceInfo, __FUNCTION__"++.\n");

	// If you don't need to perform any functions
	// except to call the base class KDriver::Unload(),
	// then this entire routine may be safely deleted.

    // Call base class to delete all devices.
	KDriver::Unload();

	T.Trace(TraceInfo, __FUNCTION__"--.\n");
}
