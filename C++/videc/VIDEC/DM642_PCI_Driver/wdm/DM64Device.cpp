// DM64Device.cpp
//
// Generated by DriverWizard 3.2.0 (Build 2485)
// Requires DDK and DriverWorks
// File created on 9/29/2007
//
// This source file contains the implementation of a subclass of KDevice.
// WDM drivers implement a subclass of KPnpDevice and override member
// functions to handle requests (IRPs) from the system.
//
#include <vdw.h>
#include "DM64Driver.h"
#include "DM64Queue.h"
#include "DM64Device.h"
#include "..\\intrface.h"

#pragma hdrstop("DM64.pch")

// Global driver trace object
// TODO:	Use KDebugOnlyTrace if you want trace messages
//			to appear only in checked builds.  Use KTrace if
//			you want trace messages to always appear.  Call
//			method SetOutputLevel to set the output threshold.
extern KDebugOnlyTrace T;

///////////////////////////////////////////////////////////////////////////////////////////////////
//  DM64Device::DM64Device
//		This is the constructor for the class representing the Functional
//		Device Object, or FDO.  It is derived from KPnpDevice, which builds
//		in automatic dispatching of subfunctions of IRP_MJ_POWER and IRP_MJ_PNP
//		to virtual member functions.
//		The object being constructed contains a data member (m_Lower) of type
//		KPnpLowerDevice. By initializing it, the driver binds the FDO to the
//		PDO and creates an interface to the upper edge of the system class driver.
//
//	Arguments:
//		IN	Pdo
//				Physical Device Object.  This is a pointer to a system
//				device object that represents the physical device.
//
//		IN	Unit
//				Unit number to append to the device's base device name 
//				to distinguish multiple units of this device type.
//
//	Return Value:
//		none
//
#define MAX_READ_FIFO_SIZE 0x2000

DM64Device::DM64Device(PDEVICE_OBJECT Pdo, ULONG Unit) :
	KPnpDevice(Pdo, &GUID_DEVINTERFACE_DM64),
	m_ReadQueue(),
	m_WriteQueue(),
	m_AppNotificationEvent(NULL),
	m_ReadFifo(MAX_READ_FIFO_SIZE, NonPagedPool),
	m_ReadPended(FALSE)
{
	if (!NT_SUCCESS(m_ConstructorStatus))
	{
		T.Trace(TraceError, __FUNCTION__": Failed to create device DM64Device"
			" unit number %d status %x\n", Unit, m_ConstructorStatus);
		ASSERT(FALSE);
		return;
	}

	// Initialize the lower device
	m_Lower.Initialize(this, Pdo);

	// Inform the base class of the lower edge device object
	SetLowerDevice(&m_Lower);

	// Initialize the PnP Policy settings to the "standard" policy
	SetPnpPolicy();

	// Initialize the Power Policy settings to the "standard" policy
	SetPowerPolicy();
	
	// Initialize driver managed queue
	m_ReadQueue.Initialize(Pdo);
	m_WriteQueue.Initialize(Pdo);
}

///////////////////////////////////////////////////////////////////////////////////////////////////
//  DM64Device::~DM64Device
//		This is the destructor for the class. 
//
//	Arguments:
//		none
//
//	Return Value:
//		none
//
DM64Device::~DM64Device()
{
}

///////////////////////////////////////////////////////////////////////////////////////////////////
//  DM64Device::DefaultPnp
//		Default handler for IRP_MJ_PNP. 
//		This routine just passes the IRP through to the lower device. IRPs 
//		that correspond to any virtual members of KpnpDevice that handle 
//		minor functions of IRP_MJ_PNP and that are not overridden get 
//		passed to this routine.
//
//	Arguments:
//		IN	I
//			the plug and play IRP
//
//	Return Value:
//		NTSTATUS
//			Result returned from lower device
//
NTSTATUS DM64Device::DefaultPnp(KIrp I)
{
	T.Trace(TraceInfo, __FUNCTION__"++.  IRP %p\n", I);
	T << I; 

	I.ForceReuseOfCurrentStackLocationInCalldown();
	NTSTATUS status = m_Lower.PnpCall(this, I);

	T.Trace(TraceInfo, __FUNCTION__"--.  IRP %p, STATUS %x\n", I, status);

	return status;
}

///////////////////////////////////////////////////////////////////////////////////////////////////
//  DM64Device::DefaultPower
//		Default handler for IRP_MJ_POWER. 
//		This routine just passes the IRP through to the lower device. IRPs 
//		that correspond to any virtual members of KpnpDevice that handle 
//		minor functions of IRP_MJ_POWER and that are not overridden get 
//		passed to this routine.
//
//	Arguments:
//		IN	I
//			the power IRP
//
//	Return Value:
//		NTSTATUS
//			Result returned from lower device
//
NTSTATUS DM64Device::DefaultPower(KIrp I)
{
	T.Trace(TraceInfo, __FUNCTION__"++.  IRP %p\n", I);
	T << I; 

	I.IndicatePowerIrpProcessed();
	I.CopyParametersDown();
	NTSTATUS status = m_Lower.PnpPowerCall(this, I);

	T.Trace(TraceInfo, __FUNCTION__"--.  IRP %p, STATUS %x\n", I, status);

	return status;
}

///////////////////////////////////////////////////////////////////////////////////////////////////
//  DM64Device::SystemControl
//		Default handler for IRP_MJ_SYSTEM_CONTROL. 
//		This routine just passes the IRP through to the next device since 
//		this driver is not a WMI provider.
//
//	Arguments:
//		IN	I
//			the system control (WMI) IRP
//
//	Return Value:
//		NTSTATUS
//			Result returned from lower device
//
NTSTATUS DM64Device::SystemControl(KIrp I)
{
	T.Trace(TraceInfo, __FUNCTION__"++.  IRP %p\n", I);
	T << I; 

	NTSTATUS status = STATUS_SUCCESS;

	I.ForceReuseOfCurrentStackLocationInCalldown();
	status = m_Lower.PnpCall(this, I);

	T.Trace(TraceInfo, __FUNCTION__"--.  IRP %p, STATUS %x\n", I, status);

	return status;
}

///////////////////////////////////////////////////////////////////////////////////////////////////
//  DM64Device::OnStartDevice
//		Handler for IRP_MJ_PNP subfcn IRP_MN_START_DEVICE. 
//		Initialize the hardware device. Typically, the driver initializes
//		physical resources here.  Call I.AllocatedResources() for a list
//		of the raw resources that the system has assigned to the device,
//		or I.TranslatedResources() for the translated resource list.
//
//	Arguments:
//		IN	I
//			the start device IRP
//
//	Return Value:
//		NTSTATUS
//
NTSTATUS DM64Device::OnStartDevice(KIrp I)
{
	T.Trace(TraceInfo, __FUNCTION__"++.  IRP %p\n", I);

	NTSTATUS status = STATUS_SUCCESS;
	PHYSICAL_ADDRESS physicalAddress = {0, 0};

	I.Information() = 0;

	PCM_RESOURCE_LIST pResListRaw = I.AllocatedResources();
	PCM_RESOURCE_LIST pResListTranslated = I.TranslatedResources();

	do
	{
		status = m_Chip.Initialize(m_Lower.TopOfStack(), pResListTranslated, pResListRaw, LinkTo(Isr), this);
		if ( !NT_SUCCESS(status) )
		{
			T.Trace(TraceWarning, "Plx chip initialization failed. Status: %d\n", status);
			break;
		}

		physicalAddress.LowPart = 0x80000000;
		physicalAddress.HighPart = 0;

		m_ReceiveLogicalAddress = (PUCHAR)MmAllocateContiguousMemory(4 * 1024 * 1024, physicalAddress);
		if (m_ReceiveLogicalAddress == NULL)
		{
			status = STATUS_UNSUCCESSFUL;
			break;
		}

		physicalAddress.LowPart = 0x80000000;
		physicalAddress.HighPart = 0;

		m_SendLogicalAddress = (PUCHAR)MmAllocateContiguousMemory(4 * 1024 * 1024, physicalAddress);
		if (m_SendLogicalAddress == NULL)
		{
			status = STATUS_UNSUCCESSFUL;
			break;
		}

		physicalAddress = MmGetPhysicalAddress((PVOID)m_ReceiveLogicalAddress);
		m_ReceivePhysicalAddress = (PUCHAR)physicalAddress.LowPart;
		
		physicalAddress = MmGetPhysicalAddress((PVOID)m_SendLogicalAddress);
		m_SendPhysicalAddress = (PUCHAR)physicalAddress.LowPart;
		
		// Setup the Deferred Procedure Call (DPC) to be used for interrupt processing
		m_DM64IsrDpc.Setup(LinkTo(IsrDpc), this);

		m_Chip.EnableInterrupts();

	} while (FALSE);

	if (!NT_SUCCESS(status))
	{
		FreeResources();
	}

	T.Trace(TraceInfo, __FUNCTION__"--.  IRP %p, STATUS %x\n", I, status);
	return status;
}

///////////////////////////////////////////////////////////////////////////////////////////////////
//  DM64Device::OnStopDevice
//		Handler for IRP_MJ_PNP subfcn IRP_MN_STOP_DEVICE. 
//		The system calls this when the device is stopped.  Release any 
//		hardware resources in this routine.
//
//	Arguments:
//		IN	I
//			the stop device IRP
//
//	Return Value:
//		NTSTATUS
//
NTSTATUS DM64Device::OnStopDevice(KIrp I)
{
	T.Trace(TraceInfo, __FUNCTION__".  IRP %p\n", I);

	// Release the system resources
	FreeResources();

	return STATUS_SUCCESS;
}

///////////////////////////////////////////////////////////////////////////////////////////////////
//  DM64Device::OnRemoveDevice
//		Handler for IRP_MJ_PNP subfcn IRP_MN_REMOVE_DEVICE. 
//		The system calls this when the device is removed.
//		Our PnP policy will take care of 
//			(1) giving the IRP to the lower device
//			(2) detaching the PDO
//			(3) deleting the device object
//
//	Arguments:
//		IN	I
//			the remove device IRP
//
//	Return Value:
//		NTSTATUS
//
NTSTATUS DM64Device::OnRemoveDevice(KIrp I)
{
	T.Trace(TraceInfo, __FUNCTION__".  IRP %p\n", I);

	// Release the system resources
	FreeResources();

	return STATUS_SUCCESS;
}

///////////////////////////////////////////////////////////////////////////////////////////////////
//  DM64Device::OnDevicePowerUp
//		Handler for IRP_MJ_POWER subfcn IRP_MN_SET_POWER 
//		for a request to go to power on state from low power state
//		This function was called by the framework from the completion
//		routine of the IRP_MJ_POWER dispatch handler in KPnpDevice.
//		The bus driver has completed the IRP and this driver can now
//		access the hardware device.  
//		This routine runs at DISPATCH_LEVEL.
//
//	Arguments:
//		IN	I
//			the power IRP
//
//	Return Value:
//		NTSTATUS
//
NTSTATUS DM64Device::OnDevicePowerUp(KIrp I)
{
	T.Trace(TraceInfo, __FUNCTION__"++.  IRP %p\n", I);

	NTSTATUS status = STATUS_SUCCESS;

	// TODO: Add device-specific code to:
	//		 Restore any context to the hardware device that
	//		 was saved during the handling of a power down request.
	//		 See the OnDeviceSleep function.
	//		 Do NOT complete this IRP.
    //		 The base class will handle completion of the IRP

	// TODO: Enable interrupts on the hardware

	T.Trace(TraceInfo, __FUNCTION__"--.  IRP %p, STATUS %x\n", I, status);

	return status;
}

///////////////////////////////////////////////////////////////////////////////////////////////////
//  DM64Device::OnDeviceSleep
//		Handler for IRP_MJ_POWER subfcn IRP_MN_SET_POWER 
//		for a request to go to a low power state from a high power state
//		This function was called by the framework from the IRP_MJ_POWER 
//		dispatch handler in KPnpDevice prior to forwarding to the PDO.
//		The hardware has yet to be powered down and this driver can now
//		access the hardware device.  
//		This routine runs at PASSIVE_LEVEL.
//
//	Arguments:
//		IN	I
//			the power IRP
//
//	Return Value:
//		NTSTATUS
//
NTSTATUS DM64Device::OnDeviceSleep(KIrp I)
{
	T.Trace(TraceInfo, __FUNCTION__"++.  IRP %p\n", I);

	NTSTATUS status = STATUS_SUCCESS;

	// TODO: Add device-specific code to:
	//		 Save any context to the hardware device that will be required 
	//		 during a power up request. See the OnDevicePowerUp function.
	//		 Do NOT complete this IRP.  The base class handles forwarding
	//		 this IRP to the PDO.

	// TODO: Disable interrupts on the hardware

	T.Trace(TraceInfo, __FUNCTION__"--.  IRP %p, STATUS %x\n", I, status);

	return status;
}


///////////////////////////////////////////////////////////////////////////////////////////////////
//  DM64Device::Create
//		Dispatch routine for IRP_MJ_CREATE requests.  
//
//	Arguments:
//		IN I 
//			the create IRP
//
//	Return Value:
//		NTSTATUS
//
NTSTATUS DM64Device::Create(KIrp I)
{
	T.Trace(TraceInfo, __FUNCTION__".  IRP %p\n", I);

	// At this point, perform custom processing for IRP_MJ_CREATE
	// Generally a create IRP is targeted at our FDO, so its not needed
	// to pass it down to the PDO.  
	return I.PnpComplete(this, STATUS_SUCCESS);
}

///////////////////////////////////////////////////////////////////////////////////////////////////
//  DM64Device::Close
//		Dispatch routine for IRP_MJ_CLOSE requests.  
//
//	Arguments:
//		IN I 
//			the close IRP
//
//	Return Value:
//		NTSTATUS
//
NTSTATUS DM64Device::Close(KIrp I)
{
	T.Trace(TraceInfo, __FUNCTION__".  IRP %p\n", I);

	// At this point, perform custom processing for IRP_MJ_CLOSE
	// Generally a close IRP is targeted at our FDO, so we don't need
	// to pass it down to the PDO.  
	I.Information() = 0;
	return I.PnpComplete(this, STATUS_SUCCESS);
}

///////////////////////////////////////////////////////////////////////////////////////////////////
//  DM64Device::SerialRead
//		Handler for serialized IRP_MJ_READ requests.  This routine is called 
//		when the IRP is removed from the queue.  This guarantees that multiple 
//		requests are never processed simultaneously.  This routine is called 
//		at DISPATCH_LEVEL unless the Queue class is initialized to call this
//		at less than DISPATCH_LEVEL.  The IRP was validated in the Read() method.
//
//	Arguments:
//		IN I 
//			the serialized read IRP
//
//	Return Value:
//		NTSTATUS
//
void DM64Device::SerialRead(KIrp I)
{
	//T.Trace(TraceInfo, __FUNCTION__"++.  IRP %p\n", I);

	NTSTATUS status = STATUS_SUCCESS;

	// Get a pointer to the caller's buffer.  Note that this
	// routine is safe on all platforms. 
	if (!m_Chip.StartMasterDma((ULONG)m_ReceivePhysicalAddress, I.ReadSize(), FromDeviceToMemory))
		status = STATUS_UNSUCCESSFUL;

    // If we fail to initiate the transfer, fail the IRP
    if (!NT_SUCCESS(status))
    {
		I.Status() = status;
		I.Information() = 0;
		m_ReadQueue.PnpNextIrp(I);
    }
	else
		m_ReadPended = TRUE;

	
	// NextIrp completes this IRP and starts processing 
	// for the next IRP in the driver managed queue.

	//T.Trace(TraceInfo, __FUNCTION__"--.  IRP %p, STATUS %x\n", I, status);
}

///////////////////////////////////////////////////////////////////////////////////////////////////
//  DM64Device::Read
//		Dispatch routine for IRP_MJ_READ requests.  
//
//	Arguments:
//		IN I 
//			the read IRP
//
//	Return Value:
//		NTSTATUS
//
NTSTATUS DM64Device::Read(KIrp I)
{
	//T.Trace(TraceInfo, __FUNCTION__"++.  IRP %p\n", I);

	NTSTATUS status = STATUS_SUCCESS;

	// Always ok to read 0 elements
	if (I.ReadSize() == 0)
	{
		I.Information() = 0;
		I.PnpComplete(this, status);

		return status;
	}

	// Queue the IRP for processing in the driver managed queue.
	// The actual read function is performed in SerialRead
	// TODO:	The Wizard creates a single queue class for all Irps and
	//			one or more instances of the class.  Review the number 
	//			and types of queues.  Select the appropriate queue for 
	//			this Irp here.
	status = m_ReadQueue.QueueIrp(I);

	//T.Trace(TraceInfo, __FUNCTION__"--.  IRP %p, STATUS %x\n", I, status);

	return status;
}

///////////////////////////////////////////////////////////////////////////////////////////////////
//  DM64Device::SerialWrite
//		Handler for serialized IRP_MJ_WRITE requests.  This routine is called 
//		when the IRP is removed from the queue.  This guarantees that multiple 
//		requests are never processed simultaneously.  This routine is called 
//		at DISPATCH_LEVEL unless the Queue class is initialized to call this
//		at less than DISPATCH_LEVEL.  The IRP was validated in the Write() method.
//
//	Arguments:
//		IN I 
//			the serialized write IRP
//
//	Return Value:
//		NTSTATUS
//
void DM64Device::SerialWrite(KIrp I)
{
	T.Trace(TraceInfo, __FUNCTION__"++.  IRP %p\n", I);

	NTSTATUS status = STATUS_SUCCESS;

	KMemory Mem(I.Mdl());	// Declare a memory object

#if 1
	// Get a pointer to the caller's buffer.  Note that this
	// routine is safe on all platforms. 
	RtlCopyMemory(m_SendLogicalAddress, Mem.MapToSystemSpace(), I.WriteSize());
	if (!m_Chip.StartMasterDma((ULONG)m_SendPhysicalAddress, I.WriteSize(), FromMemoryToDevice))
		status = STATUS_UNSUCCESSFUL;
#else

	// Get a pointer to the caller's buffer.  Note that this
	// routine is safe on all platforms. 
	PUCHAR pBuffer = (PUCHAR) Mem.MapToSystemSpace();
	ULONG writeSize = I.WriteSize();
	ULONG bytesSent = 0;

	// TODO:  Verify the device object to use.  
	status = m_MasterDmaTransfer.Initiate(
		this, 
		&m_MasterDma, 
		I.Mdl(), 
		FromMemoryToDevice, 
		LinkTo(OnMasterDmaReady), 
		NULL, 
		this);
#endif

    // If we fail to initiate the transfer, fail the IRP
    if (!NT_SUCCESS(status))
    {
		I.Status() = status;
		I.Information() = 0;
		m_WriteQueue.PnpNextIrp(I);
    }

	// NextIrp completes this IRP and starts processing 
	// for the next IRP in the driver managed queue.
	//m_DriverManagedQueue.PnpNextIrp(I);  

	T.Trace(TraceInfo, __FUNCTION__"--.  IRP %p, STATUS %x\n", I, status);
}

///////////////////////////////////////////////////////////////////////////////////////////////////
//  DM64Device::Write
//		Dispatch routine for IRP_MJ_WRITE requests.  
//
//	Arguments:
//		IN I 
//			the write IRP
//
//	Return Value:
//		NTSTATUS
//
NTSTATUS DM64Device::Write(KIrp I)
{
	T.Trace(TraceInfo, __FUNCTION__"++.  IRP %p\n", I);

	NTSTATUS status = STATUS_SUCCESS;

	// Always ok to write 0 elements
	if (I.WriteSize() == 0)
	{
		I.Information() = 0;
		I.PnpComplete(this, status);

		T.Trace(TraceInfo, __FUNCTION__"--.  IRP %p, STATUS %x\n", I, status);
		return status;
	}

	// Queue the IRP for processing in the driver managed queue.
	// The actual write function is performed in SerialWrite
	// TODO:	The Wizard creates a single queue class for all Irps and
	//			one or more instances of the class.  Review the number 
	//			and types of queues.  Select the appropriate queue for 
	//			this Irp here.
	status = m_WriteQueue.QueueIrp(I);

	T.Trace(TraceInfo, __FUNCTION__"--.  IRP %p, STATUS %x\n", I, status);
	return status;
}

///////////////////////////////////////////////////////////////////////////////////////////////////
//  DM64Device::DeviceControl
//		Dispatch routine for IRP_MJ_DEVICE_CONTROL requests.  
//
//	Arguments:
//		IN I 
//			the ioctl IRP
//
//	Return Value:
//		NTSTATUS
//
NTSTATUS DM64Device::DeviceControl(KIrp I)
{
	NTSTATUS status;

	//T.Trace(TraceInfo, __FUNCTION__"++.  IRP %p, code %u\n", I, I.IoctlCode());

	switch (I.IoctlCode())
	{
	case IOCTL_WARMRESET:
		status = IOCTL_WARMRESET_Handler(I);
		break;

	case IOCTL_RUN:
		status = IOCTL_RUN_Handler(I);
		break;

	case IOCTL_INITEMIF:
		status = IOCTL_INITEMIF_Handler(I);
		break;

	case IOCTL_LOAD:
		status = IOCTL_LOAD_Handler(I);
		break;

	case IOCTL_POST_MSG:
		status = IOCTL_POST_Handler(I);
		break;

	case IOCTL_RETRIEVE_MSG:
		status = IOCTL_RETRIEVE_Handler(I);
		break;

	case IOCTL_HOOK:
		status = Hook(*(HANDLE*)I.IoctlBuffer());
		break;

	case IOCTL_UNHOOK:
		status = Unhook();
		break;

	default:
		status = STATUS_INVALID_DEVICE_REQUEST;
		break;
	}

	// If the IRP's IOCTL handler deferred processing using some driver
	// specific scheme, the status variable is set to STATUS_PENDING.
	// In this case we simply return that status, and the IRP will be
	// completed later.  Otherwise, complete the IRP using the status
	// returned by the IOCTL handler.
	if (status != STATUS_PENDING)
	{
		I.PnpComplete(this, status);
	}

	//T.Trace(TraceInfo, __FUNCTION__"--.  IRP %p, STATUS %x\n", I, status);
	return status;
}

///////////////////////////////////////////////////////////////////////////////////////////////////
//  DM64Device::IOCTL_WARMRESET_Handler
//		Handler for ioctl IOCTL_WARMRESET.  The DeviceControl
//		method will complete the IRP.
//
//	Arguments:
//		IN I 
//			the ioctl IRP
//
//	Return Value:
//		NTSTATUS
//
NTSTATUS DM64Device::IOCTL_WARMRESET_Handler(KIrp I)
{
	m_Chip.Reset();

	T.Trace(TraceInfo, __FUNCTION__".  IRP %p, STATUS %x\n", I, STATUS_SUCCESS);
	return STATUS_SUCCESS;
}

///////////////////////////////////////////////////////////////////////////////////////////////////
//  DM64Device::IOCTL_RUN_Handler
//		Handler for ioctl IOCTL_RUN.  The DeviceControl
//		method will complete the IRP.
//
//	Arguments:
//		IN I 
//			the ioctl IRP
//
//	Return Value:
//		NTSTATUS
//
NTSTATUS DM64Device::IOCTL_RUN_Handler(KIrp I)
{
	m_Chip.Unreset();

	T.Trace(TraceInfo, __FUNCTION__".  IRP %p, STATUS %x\n", I, STATUS_SUCCESS);
	return STATUS_SUCCESS;
}

///////////////////////////////////////////////////////////////////////////////////////////////////
//  DM64Device::IOCTL_INITEMIF_Handler
//		Handler for ioctl IOCTL_INITEMIF.  The DeviceControl
//		method will complete the IRP.
//
//	Arguments:
//		IN I 
//			the ioctl IRP
//
//	Return Value:
//		NTSTATUS
//
NTSTATUS DM64Device::IOCTL_INITEMIF_Handler(KIrp I)
{
	if (I.Mdl() != NULL)
	{
		KMemory Mem(I.Mdl());
		m_Chip.SetEmif(Mem.MapToSystemSpace(), I.IoctlOutputBufferSize());
	}

	T.Trace(TraceInfo, __FUNCTION__".  IRP %p, size %d\n", I, I.IoctlOutputBufferSize());
	return STATUS_SUCCESS;
}

///////////////////////////////////////////////////////////////////////////////////////////////////
//  DM64Device::IOCTL_LOAD_Handler
//		Handler for ioctl IOCTL_LOAD.  The DeviceControl
//		method will complete the IRP.
//
//	Arguments:
//		IN I 
//			the ioctl IRP
//
//	Return Value:
//		NTSTATUS
//
NTSTATUS DM64Device::IOCTL_LOAD_Handler(KIrp I)
{
	ULONG address;
	PULONG buffer;					// Direct Buffer
	
	if (I.Mdl() != NULL)
	{
		KMemory Mem(I.Mdl());
		ULONG size = I.IoctlOutputBufferSize() - sizeof(ULONG);

		// Note that this routine is safe on all platforms.
		buffer = (PULONG)Mem.MapToSystemSpace();
		address = buffer[0];
		
		T.Trace(TraceInfo, __FUNCTION__".  dst:%x, src:%x, size:%u\n", address, &buffer[1], size);
		m_Chip.BusIop(address, (PVOID)&(buffer[1]), size, false);
	}

	T.Trace(TraceInfo, __FUNCTION__".  IRP %p, STATUS %x\n", I, STATUS_SUCCESS);
	return STATUS_SUCCESS;
}

///////////////////////////////////////////////////////////////////////////////////////////////////
//  DM64Device::IOCTL_RETRIEVE_Handler
//		Handler for ioctl IOCTL_LOAD.  The DeviceControl
//		method will complete the IRP.
//
//	Arguments:
//		IN I 
//			the ioctl IRP
//
//	Return Value:
//		NTSTATUS
//
NTSTATUS DM64Device::IOCTL_RETRIEVE_Handler(KIrp I)
{
	T.Trace(TraceInfo, __FUNCTION__"++.  IRP %p\n", I);

	PVOID Buffer;
	ULONG header[2];
	ULONG Size;

	// Direct ioctl
	m_Chip.ReadPage0(ADDR_READ_MAILBOX, (PVOID)header, sizeof(header));

	Size = I.IoctlOutputBufferSize();
	if (Size > header[1])
		Size = header[1];

	if (Size > MAILBOX_MAX_LEN)
		Size = MAILBOX_MAX_LEN;

	I.Information() = 0;
	if (header[0] == MAGIC_REQUEST)
	{
		if ( I.Mdl() != NULL)
		{
			KMemory Mem(I.Mdl());

			// Note that this routine is safe on all platforms. 
			Buffer = Mem.MapToSystemSpace();
			m_Chip.ReadPage0(ADDR_READ_MAILBOX + sizeof(header), (PVOID)Buffer, Size);
			I.Information() = Size;
		}

		header[0] = MAGIC_ACK;
		m_Chip.WritePage0(ADDR_READ_MAILBOX, (PVOID)header, sizeof(header));
	}

	T.Trace(TraceInfo, __FUNCTION__"--.  IRP %p, STATUS %x\n", I, STATUS_SUCCESS);
	return STATUS_SUCCESS;
}

///////////////////////////////////////////////////////////////////////////////////////////////////
//  DM64Device::IOCTL_POST_Handler
//		Handler for ioctl IOCTL_LOAD.  The DeviceControl
//		method will complete the IRP.
//
//	Arguments:
//		IN I 
//			the ioctl IRP
//
//	Return Value:
//		NTSTATUS
//
NTSTATUS DM64Device::IOCTL_POST_Handler(KIrp I)
{
	T.Trace(TraceInfo, __FUNCTION__"++.  IRP %p\n", I);

	PVOID Buffer;
	ULONG header[2];
	ULONG Size;

	I.Information() = 0;
	m_Chip.ReadPage0(ADDR_WRITE_MAILBOX, (PVOID)header, sizeof(header));

	if (header[0] == MAGIC_ACK)
	{
		Size = I.IoctlOutputBufferSize();

		if (Size > MAILBOX_MAX_LEN)
			Size = MAILBOX_MAX_LEN;

		header[0] = MAGIC_REQUEST;
		header[1] = Size;

		// Direct ioctl
		if (I.Mdl() != NULL)
		{
			KMemory Mem(I.Mdl());

			// Note that this routine is safe on all platforms. 
			Buffer = Mem.MapToSystemSpace();
			m_Chip.WritePage0(ADDR_WRITE_MAILBOX, (PVOID)header, sizeof(header));
			m_Chip.WritePage0(ADDR_WRITE_MAILBOX + sizeof(header), (PVOID)Buffer, Size);

			I.Information() = Size;
		}
	}

	T.Trace(TraceInfo, __FUNCTION__"--.  IRP %p, STATUS %x\n", I, STATUS_SUCCESS);
	return STATUS_SUCCESS;
}

///////////////////////////////////////////////////////////////////////////////////////////////////
//  DM64Device::CleanUp
//		Dispatch routine for IRP_MJ_CLEANUP requests.  
//
//	Arguments:
//		IN I 
//			the cleanup IRP
//
//	Return Value:
//		NTSTATUS
//
NTSTATUS DM64Device::CleanUp(KIrp I)
{
	KIrp currentI;

	// Clean up the driver managed IRP queues for the file
	// object specified in the cleanup IRP
	m_ReadQueue.PnpCleanUp(this, I.FileObject());
	m_WriteQueue.PnpCleanUp(this, I.FileObject());

	m_ReadFifo.Lock();
	if (m_ReadPended)
	{
		currentI = m_ReadQueue.CurrentIrp();

		T.Trace(TraceInfo, __FUNCTION__"*****.  read IRP %p\n", currentI);

		if (!currentI.IsNull())
		{
			currentI.Information() = 0;
			currentI.Status() = STATUS_CANCELLED;
		}

		m_ReadPended = FALSE;
		m_ReadFifo.Unlock();
		m_ReadQueue.PnpNextIrp(currentI);
	}
	else
		m_ReadFifo.Unlock();

	currentI = m_WriteQueue.CurrentIrp();
	if (!currentI.IsNull())
	{
		T.Trace(TraceInfo, __FUNCTION__"@@@@@.  write IRP %p\n", currentI);

		currentI.Information() = 0;
		currentI.Status() = STATUS_CANCELLED;
		m_WriteQueue.PnpNextIrp(currentI);
	}

	T.Trace(TraceInfo, __FUNCTION__".  IRP %p, STATUS %x\n", I, STATUS_SUCCESS);
	return I.PnpComplete(this, STATUS_SUCCESS);;
}

///////////////////////////////////////////////////////////////////////////////////////////////////
//  DM64Device::Isr
//		Interrupt Service Routine (ISR).  Minimal processing may be done 
//		here in the ISR, but most processing should be deferred to a DPC.
//		This routine is called at DEVICE IRQL that is higher than 
//		DISPATCH_LEVEL.
//
//	Arguments:
//		none
//
//	Return Value:
//		BOOLEAN		TRUE if this is our interrupt
//
BOOLEAN DM64Device::Isr(void)
{
	C6000_ISR_REASON reason;
	
	reason = m_Chip.GetIsrReason();
	if (reason == C6000ReasonNone)
	{
		// Return FALSE to indicate that this device did not cause the interrupt.
		return FALSE;
	}

	// Service the device.
	//	 Minimal processing may be done here in the ISR, but
	//	 most processing should be deferred to a DPC.
	//	 Generally, you should:
	//		o  stop the device from generating interrupts
	//		o  get the reason for the interrupt (DMA done, read complete,
	//				write complete, other operation complete)
	//		o  perform any additional time-critical functions
	//		o  schedule a DPC to perform the bulk of the work.
	m_Chip.DisableInterrupts();
	m_DM64IsrDpc.Request((PVOID)reason, NULL);

	return TRUE;
}

///////////////////////////////////////////////////////////////////////////////////////////////////
//  DM64Device::IsrDpc
//		Deferred Procedure Call (DPC).
//		This function is called for secondary processing of an interrupt.
//		Most code that runs at elevated IRQL should run here rather than
//		in the ISR, so that other interrupt handlers can continue to run.
//		This routine executes at DISPATCH_LEVEL.
//
//	Arguments:
//		IN	Arg1
//				User-defined context variable passed from Isr()
//
//		IN	Arg2
//				User-defined context variable passed from Isr()
//
//	Return Value:
//		none
//
VOID DM64Device::IsrDpc(PVOID Arg1, PVOID Arg2)
{
	//T.Trace(TraceInfo, __FUNCTION__"++\n");

	DM64_ISR_REASON reason = (DM64_ISR_REASON)(ULONG_PTR) Arg1;

	ULONG stuff[3], size;
	ULONG magic = MAGIC_ACK;
	int direction, id;

	m_Chip.ClearIsrReason();
	m_Chip.ReadPage0(ADDR_DSP_NOTIFY, (PVOID)stuff, sizeof(stuff));

	if (stuff[0] == MAGIC_REQUEST)
	{
		m_ReadFifo.Lock();

		if (!m_ReadPended)
		{
			m_ReadFifo.Unlock();
			goto Exit;
		}

		direction = (stuff[1] >> 28) & 0x0F;
		id = (stuff[1] >> 16) & 0xFFF;
		size = stuff[2];

		if (id == 1)
		{
			KIrp I;
			DM64Queue *queue;

			// Make a KIrp object to reference the current Irp
			// select the appropriate queue for this Irp here.
			if (direction == READ_COMPLETE)
			{
				queue = &m_ReadQueue;
			}
			else if (direction == WRITE_COMPLETE)
			{
				queue = &m_WriteQueue;			
			}
			
			I = queue->CurrentIrp();
			if (I.IsNull())
				m_ReadFifo.Unlock();
			else
			{
				if (direction == READ_COMPLETE)
				{
					KMemory Mem(I.Mdl());

					size = Mem.Size() > size ? size :Mem.Size();
					RtlCopyMemory(Mem.MapToSystemSpace(), 
								m_ReceiveLogicalAddress,
								size);
				}

				m_ReadPended = FALSE;

				I.Status() = STATUS_SUCCESS;
				I.Information() = size;

				m_ReadFifo.Unlock();

				// PnpNextIrp completes this IRP and starts processing 
				// for the next IRP in the driver managed queue.
				queue->PnpNextIrp(I);
			}

		}
Exit:
		m_Chip.WritePage0(ADDR_DSP_NOTIFY, (PVOID)&magic, sizeof(magic));
	}
	else
	{
		m_Chip.ReadPage0(ADDR_READ_MAILBOX, (PVOID)&magic, sizeof(magic));
		if (magic == MAGIC_REQUEST)
		{
			if (m_AppNotificationEvent) 
				m_AppNotificationEvent->Set();
		}
	}

	m_Chip.EnableInterrupts(true);
}

///////////////////////////////////////////////////////////////////////////////////////////////////
//  DM64Device::Invalidate
//		This method performs resource cleanup.
//		This function is called from OnStopDevice, OnRemoveDevice and
//		OnStartDevice (in error conditions).  It calls the Invalidate
//		member funcitons for each resource to free the underlying system
//		resource if allocated.  It is safe to call Invalidate more than
//		once for a resource, or for an uninitialized resource.
//
//	Arguments:
//		none
//
//	Return Value:
//		none
//
VOID DM64Device::FreeResources()
{
	m_Chip.DisableInterrupts();

	m_Chip.Invalidate();

	if (m_ReceiveLogicalAddress)
	{
		MmFreeContiguousMemory(m_ReceiveLogicalAddress);

		m_ReceiveLogicalAddress = NULL;
		m_ReceivePhysicalAddress = NULL;
	}

	if (m_SendLogicalAddress)
	{
		MmFreeContiguousMemory(m_SendLogicalAddress);

		m_SendLogicalAddress = NULL;
		m_SendPhysicalAddress = NULL;
	}

	Unhook();
}

//////////////////////////////////////////////////////////////////////////
// Hooking/unhooking
NTSTATUS DM64Device::Hook(HANDLE hUserEvent)
{
	T.Trace(TraceInfo, __FUNCTION__"\n");

	if (m_AppNotificationEvent)
		delete m_AppNotificationEvent;

	if (hUserEvent)
		m_AppNotificationEvent = new (NonPagedPool) KEvent(hUserEvent);
	else
		m_AppNotificationEvent = NULL;

	return STATUS_SUCCESS;
}

NTSTATUS DM64Device::Unhook()
{
	T.Trace(TraceInfo, __FUNCTION__"\n");

	delete m_AppNotificationEvent;
	m_AppNotificationEvent = NULL;

	return STATUS_SUCCESS;
}
