// DM64Queue.cpp
//
// Generated by DriverWizard 3.2.0 (Build 2485)
// Requires DDK and DriverWorks
// File created on 9/29/2007
//
// This source file contains the implementation of a subclass of KDriverManagedQueueCsq.
// This class implements a driver managed queue that serializes IRP
// processing so that requests are processed one at a time.  Not all
// IRP's are required to use a queue.  More than one instance of this
// queue may be used.  For instance, the driver may be able to process
// reads and writes at the same time (i.e. 2 different channels.)
// This class has the benefit of NOT using the system global cancel
// spin lock.
//

#include <vdw.h>

#include "DM64Driver.h"
#include "DM64Queue.h"
#include "DM64Device.h"

#pragma hdrstop("DM64.pch")

// Global driver trace object
// TODO:	Use KDebugOnlyTrace if you want trace messages
//			to appear only in checked builds.  Use KTrace if
//			you want trace messages to always appear.  Call
//			method SetOutputLevel to set the output threshold.
extern KDebugOnlyTrace T;

///////////////////////////////////////////////////////////////////////////////////////////////////
//  DM64Queue::StartIo
//		This routine is called when the driver is loaded.  NT drivers
//		create device objects.  Drivers often read the registry for
//		configurable parameters.
//
//	Arguments:
//		IN	RegistryPath
//				pointer to a unicode string representing the path to
//				driver-specific key in the registry.  Look for:
//				HKLM\SYSTEM\CurrentControlSet\Services\DM64
//
//	Return Value:
//		NTSTATUS code
//
VOID DM64Queue::StartIo(KIrp I)
{
	//T.Trace(TraceInfo, __FUNCTION__"++.  IRP %p\n", I);

	// The KDriverManagedQueueCsq uses system IO_CSQ and IoCsqXXX set of DDK functions
	// to handle cancaling logic so we can process it without having to worry
	// about clearing the cancel routine first, as is the case with system queuing,
	// or the legacy class KDriverManagedQueue. You may want to set a different cancel
	// routine here, or at other points during the processing of this Irp.

	// Find the device class so we can call the serialized
	// routines in the device class.  The handlers can be
	// moved to this class if it is more convenient.
	DM64Device *pDev = (DM64Device*) KDevicePTR(I.DeviceObject());
	ASSERT(pDev);

	switch (I.MajorFunction())
	{
	case IRP_MJ_READ:
		pDev->SerialRead(I);
		break;

	case IRP_MJ_WRITE:
		pDev->SerialWrite(I);
		break;

	case IRP_MJ_DEVICE_CONTROL:
		switch (I.IoctlCode())
		{
		case 0:
		default:
			// Error - A request was queued that shouldn't have been
			// (should never get here)
			ASSERT(FALSE);
			break;
		}
		break;

	default:
		// Error - A request was queued that shouldn't have been
		// (should never get here)
		ASSERT(FALSE);
		I.Status() = STATUS_INVALID_PARAMETER;

		// NextIrp completes this IRP and starts processing
		// for the next IRP in the queue.
		NextIrp(I);
		break;
	}

	//T.Trace(TraceInfo, __FUNCTION__"--.  IRP %p\n", I);
}
